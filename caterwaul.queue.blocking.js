// Asynchronous blocking queue | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module provides a CPS-converted blocking queue, as is appropriate for something like filehandle allocation for a node.js server. The basic idea is that you want to create a request for
// some resource, then service that request, and finally free the resource; but you want to do this in a non-blocking way that prevents starvation. Optimistic locking doesn't provide this
// guarantee, so I'm writing a blocking queue to do it.

// Interface.
// Queues are created using the caterwaul.queue.blocking() function, which takes an integer for the size. Once you have a queue:

// | var queue = caterwaul.queue.blocking(10);

// You can make requests by invoking it on a callback:

// | queue(function (free) {
//     // Do stuff here
//     nonblocking_call(function (...) {
//       // Free the resource:
//       free();
//     });
//   });

caterwaul.tconfiguration('std', 'queue.blocking', function () {
  (this.queue || this.shallow('queue', {}).queue).blocking(n) =
  let*[used = 0, waiting = [], allocate(cc) = used < n ? (++used, cc(deallocate)) : waiting.push(cc), deallocate() = waiting.length ? waiting.shift()(deallocate) : --used] in allocate;
});

// Generated by SDoc 
