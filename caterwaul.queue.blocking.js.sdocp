sdocp('caterwaul.queue.blocking.js.sdoc', 'Asynchronous blocking queue | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThis module provides a CPS-converted blocking queue, as is appropriate for something like filehandle allocation for a node.js server. The basic idea is that you want to create a request for\nsome resource, then service that request, and finally free the resource; but you want to do this in a non-blocking way that prevents starvation. Optimistic locking doesn\'t provide this\nguarantee, so I\'m writing a blocking queue to do it.\n\nInterface.\nQueues are created using the caterwaul.queue.blocking() function, which takes an integer for the size and an optional hash. Once you have a queue:\n\n| var queue = caterwaul.queue.blocking(10);\n\nYou can make requests by invoking it on a callback:\n\n| queue(function (free) {\n    // Do stuff here\n    nonblocking_call(function (...) {\n      // Free the resource:\n      free();\n    });\n  });\n\n  Options.\n  Right now the only option supported is \'empty\', which is called when the blocking queue\'s last item is removed. For example:\n\n  | caterwaul.queue.blocking(10, {empty: fn_[console.log(\'Empty queue!\')]});\n\ncaterwaul.tconfiguration(\'std\', \'queue.blocking\', function () {\n  (this.queue || this.shallow(\'queue\', {}).queue).blocking(n, options) =\n  let*[used = 0, waiting = [], deallocate() = waiting.length ? waiting.shift()(deallocate) : --used || options /se[_ && _.empty /se[_ && _()]]] in\n  fn[cc][used < n ? cc(deallocate) /se[++used] : waiting.push(cc)];\n});\n');